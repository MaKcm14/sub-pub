# Sub/Pub-service
Данный сервис является реализацией паттерна **Sub/Pub** (подписчик/издатель), написанного в рамках тестового задания стажировки VK.
<hr>
<hr>

## Описание
Задание состояло из двух частей:
1. Написание пакета `subpub` для локальной реализации паттерна
2. Написание самого сервиса, реализованного через механизм `GRPC`

<hr>

### Часть-1
Реализацию пакета данной части можно найти в папке `pkg`.

Основная суть работы данного пакета заключается в том, 
что базовой единицей, обеспечивающей работу пакета, выступает так называемая подписка, реализованная в `channelSub`. В основном её характеризует именно функция-обработчик, позволяющая в рамках текущей подписки клиента обрабатывать сообщения по-своему, и флаг активности подписки, отвечающий за состояние работы подписки (то есть нужно ли её вообще учитывать).

Каждый `subject` (в рамках реализации синонимом к нему выступает `channel`) отвечает за конкретную тематику, за конкретный именованный канал и все подписки, которые были созданы на него. Такой `subject` релизуется в `channelConfig`.

`eventChannel` в реализации отвечает за основную логику работы с данными `subject`'ами и соответственно реализует интерфейс `SubPub`.

Пакет обеспечивает корректное завершение работы всех горутин через закрытие каналов (в случае, если контекст не отменён).

Для данного пакета были написаны `unit-тесты`, которые проверяют основную логику его работы, начиная с логики по проверке соблюдения порядка `FIFO` в очередях и заканчивая проверкой `negative cases`.
<hr>

#### P.S.
Если в целом проходиться по требованиям, предъявленным к шине событий, то можно отметить:
1. **На один `subject` может подписываться и отписываться множество подписчиков:**

   Это реализуется через общую мапу, которая в рамках одного `subject`'а хранит все `channelSub`.

2. **Один медленный подписчик не должен тормозить остальных:**

   Это реализуется через горутины, в которых и запускаются функции-обработчики. Таким образом, для разных подписок будет создана своя очередь горутин,
   которая будет "тормозить" только одного подписчика, но не остальных.

3. **Нельзя терять порядок сообщений (`FIFO`-очередь):**

   Это реализуется через механизм синхронизации горутин, а именно через каналы: представим, что есть i-ая и i+1-ая горутины, которые относятся к одной подписке.
   Тогда их синхронизация будет таковой, что пока i-ая горутина не закончит обработку в функции подписки, сообщение не будет послано этой горутиной в небуферезированный канал, который читает i+1-ая горутина.

4. **Метод `Close` должен учитывать переданный контекст. Если он отменен - выходим сразу, работающие хендлеры оставляем работать:**

   Это реализуется через проверку канала завершения, возвращаемого методом `Done`.

5. **Горутины течь не должны:**

   Для корректного завершения работы всех горутин существует метод `close` у каждого `channelConfig`, который для каждой последней запущенной горутины считывает после её работы данные из канала и закрывает канал, что обеспечивает завершение горутины.

<hr>

### Часть-2
В данной части задания необходимо было реализовать сервис подписок на основе пакета `subpub`. Был предоставлен контракт в виде `proto-файла`, на основе которого и обеспечивалось написание сервиса. Основная логика работы такова:

В сервисе обеспечивается реализация функций для публикации событий и для подписок на них.
При публикации вызывается удалённо метод `Publish`, который вызывает метод `Publish` пакета `subpub`, который позволяет опубликовывать события для всех подписчиков канала.

В свою очередь, подписчики вызывают метод `Subscribe`, возвращающий `stream` для работы с сервисом: при очередном вызове `Publish` происходит вызов `handler`'а, 
который передаёт данные в канал, откуда они затем передаются в `stream` клиенту.

Помимо этого в сервисе был реализован тестовый клиент, который позволяет протестировать основную логику работы сервера (реализован в `test/client`).

Согласно заданию сервис также обеспечивает:
- логирование и хранение логов о своей работе в папке `logs` (в одноимённом томе `Docker`'а)
- наличие файла конфигурации (`.env` в корне проекта), в котором указывается сокет, на котором сервис будет ожидать клиентских соединений

<hr>

## Как собирать?
Для упрощения развертывания сервиса используется `Docker`. Для того чтобы собрать сервис, необходимо проделать следующее:
1. `git clone https://github.com/MaKcm14/vk-test.git`
2. `cd vk-test`
3. `docker compose build`
4. `docker compose up -d`

После чего будет поднят контейнер с приложением на сокете, указанном в файле конфигурации (см. пример файла `.env_example` в корне проекта).

### P.S.
- По умолчанию происходит проброс портов на хост.

- По умолчанию сервис настроен на запуск на порте `:9736`.

- По желанию можно изменить дефолтный сокет: при изменении файла конфигурации необходимо будет скорректировать данные в файле `docker-compose.yml` и `Dockerfile`.

<hr>

## Особенности реализации
В реализации были применены некоторые паттерны, среди которых можно выделить:
1. *Dependency Injection*:

   Реализуется через возможность получения зависимостей из параметра конструктора `NewSubPubService`.
 
2. *Graceful Shutdown*:

   Реализуется через graceful shutdown `GRPC`- сервера, а также через корректное завершение работы `eventChannel` через метод `Close`.
   
3. *Clean Architecture*:

   В данном случае ввиду специфики сервиса можно выделить два основных слоя, которые были реализованы:

   - *Interface Adapters* реализует контроллер для "общения" с внешним миром через `GRPC`: он реализован в папке `controller`.
   - *Use Cases* реализует саму логику работы приложения: в данном случае ввиду избыточности добавления отдельного слоя c объектами (так как нет доп. логики) используется интерфейс `SubPub` напрямую сразу в контроллере, который и представляет собой объект данного слоя.
